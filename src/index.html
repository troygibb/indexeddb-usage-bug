<!DOCTYPE html>
<html>
  <body>
    <script>
      "use strict";

      (function() {
        function toArray(arr) {
          return Array.prototype.slice.call(arr);
        }

        function promisifyRequest(request) {
          return new Promise(function(resolve, reject) {
            request.onsuccess = function() {
              resolve(request.result);
            };

            request.onerror = function() {
              reject(request.error);
            };
          });
        }

        function promisifyRequestCall(obj, method, args) {
          var request;
          var p = new Promise(function(resolve, reject) {
            request = obj[method].apply(obj, args);
            promisifyRequest(request).then(resolve, reject);
          });

          p.request = request;
          return p;
        }

        function promisifyCursorRequestCall(obj, method, args) {
          var p = promisifyRequestCall(obj, method, args);
          return p.then(function(value) {
            if (!value) return;
            return new Cursor(value, p.request);
          });
        }

        function proxyProperties(ProxyClass, targetProp, properties) {
          properties.forEach(function(prop) {
            Object.defineProperty(ProxyClass.prototype, prop, {
              get: function() {
                return this[targetProp][prop];
              },
              set: function(val) {
                this[targetProp][prop] = val;
              }
            });
          });
        }

        function proxyRequestMethods(
          ProxyClass,
          targetProp,
          Constructor,
          properties
        ) {
          properties.forEach(function(prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function() {
              return promisifyRequestCall(this[targetProp], prop, arguments);
            };
          });
        }

        function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
          properties.forEach(function(prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function() {
              return this[targetProp][prop].apply(this[targetProp], arguments);
            };
          });
        }

        function proxyCursorRequestMethods(
          ProxyClass,
          targetProp,
          Constructor,
          properties
        ) {
          properties.forEach(function(prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function() {
              return promisifyCursorRequestCall(
                this[targetProp],
                prop,
                arguments
              );
            };
          });
        }

        function Index(index) {
          this._index = index;
        }

        proxyProperties(Index, "_index", [
          "name",
          "keyPath",
          "multiEntry",
          "unique"
        ]);

        proxyRequestMethods(Index, "_index", IDBIndex, [
          "get",
          "getKey",
          "getAll",
          "getAllKeys",
          "count"
        ]);

        proxyCursorRequestMethods(Index, "_index", IDBIndex, [
          "openCursor",
          "openKeyCursor"
        ]);

        function Cursor(cursor, request) {
          this._cursor = cursor;
          this._request = request;
        }

        proxyProperties(Cursor, "_cursor", [
          "direction",
          "key",
          "primaryKey",
          "value"
        ]);

        proxyRequestMethods(Cursor, "_cursor", IDBCursor, ["update", "delete"]);

        // proxy 'next' methods
        ["advance", "continue", "continuePrimaryKey"].forEach(function(
          methodName
        ) {
          if (!(methodName in IDBCursor.prototype)) return;
          Cursor.prototype[methodName] = function() {
            var cursor = this;
            var args = arguments;
            return Promise.resolve().then(function() {
              cursor._cursor[methodName].apply(cursor._cursor, args);
              return promisifyRequest(cursor._request).then(function(value) {
                if (!value) return;
                return new Cursor(value, cursor._request);
              });
            });
          };
        });

        function ObjectStore(store) {
          this._store = store;
        }

        ObjectStore.prototype.createIndex = function() {
          return new Index(
            this._store.createIndex.apply(this._store, arguments)
          );
        };

        ObjectStore.prototype.index = function() {
          return new Index(this._store.index.apply(this._store, arguments));
        };

        proxyProperties(ObjectStore, "_store", [
          "name",
          "keyPath",
          "indexNames",
          "autoIncrement"
        ]);

        proxyRequestMethods(ObjectStore, "_store", IDBObjectStore, [
          "put",
          "add",
          "delete",
          "clear",
          "get",
          "getAll",
          "getKey",
          "getAllKeys",
          "count"
        ]);

        proxyCursorRequestMethods(ObjectStore, "_store", IDBObjectStore, [
          "openCursor",
          "openKeyCursor"
        ]);

        proxyMethods(ObjectStore, "_store", IDBObjectStore, ["deleteIndex"]);

        function Transaction(idbTransaction) {
          this._tx = idbTransaction;
          this.complete = new Promise(function(resolve, reject) {
            idbTransaction.oncomplete = function() {
              resolve();
            };
            idbTransaction.onerror = function() {
              reject(idbTransaction.error);
            };
            idbTransaction.onabort = function() {
              reject(idbTransaction.error);
            };
          });
        }

        Transaction.prototype.objectStore = function() {
          return new ObjectStore(
            this._tx.objectStore.apply(this._tx, arguments)
          );
        };

        proxyProperties(Transaction, "_tx", ["objectStoreNames", "mode"]);

        proxyMethods(Transaction, "_tx", IDBTransaction, ["abort"]);

        function UpgradeDB(db, oldVersion, transaction) {
          this._db = db;
          this.oldVersion = oldVersion;
          this.transaction = new Transaction(transaction);
        }

        UpgradeDB.prototype.createObjectStore = function() {
          return new ObjectStore(
            this._db.createObjectStore.apply(this._db, arguments)
          );
        };

        proxyProperties(UpgradeDB, "_db", [
          "name",
          "version",
          "objectStoreNames"
        ]);

        proxyMethods(UpgradeDB, "_db", IDBDatabase, [
          "deleteObjectStore",
          "close"
        ]);

        function DB(db) {
          this._db = db;
        }

        DB.prototype.transaction = function() {
          return new Transaction(
            this._db.transaction.apply(this._db, arguments)
          );
        };

        proxyProperties(DB, "_db", ["name", "version", "objectStoreNames"]);

        proxyMethods(DB, "_db", IDBDatabase, ["close"]);

        // Add cursor iterators
        // TODO: remove this once browsers do the right thing with promises
        ["openCursor", "openKeyCursor"].forEach(function(funcName) {
          [ObjectStore, Index].forEach(function(Constructor) {
            // Don't create iterateKeyCursor if openKeyCursor doesn't exist.
            if (!(funcName in Constructor.prototype)) return;

            Constructor.prototype[
              funcName.replace("open", "iterate")
            ] = function() {
              var args = toArray(arguments);
              var callback = args[args.length - 1];
              var nativeObject = this._store || this._index;
              var request = nativeObject[funcName].apply(
                nativeObject,
                args.slice(0, -1)
              );
              request.onsuccess = function() {
                callback(request.result);
              };
            };
          });
        });

        // polyfill getAll
        [Index, ObjectStore].forEach(function(Constructor) {
          if (Constructor.prototype.getAll) return;
          Constructor.prototype.getAll = function(query, count) {
            var instance = this;
            var items = [];

            return new Promise(function(resolve) {
              instance.iterateCursor(query, function(cursor) {
                if (!cursor) {
                  resolve(items);
                  return;
                }
                items.push(cursor.value);

                if (count !== undefined && items.length == count) {
                  resolve(items);
                  return;
                }
                cursor.continue();
              });
            });
          };
        });

        var exp = {
          open: function(name, version, upgradeCallback) {
            var p = promisifyRequestCall(indexedDB, "open", [name, version]);
            var request = p.request;

            if (request) {
              request.onupgradeneeded = function(event) {
                if (upgradeCallback) {
                  upgradeCallback(
                    new UpgradeDB(
                      request.result,
                      event.oldVersion,
                      request.transaction
                    )
                  );
                }
              };
            }

            return p.then(function(db) {
              return new DB(db);
            });
          },
          delete: function(name) {
            return promisifyRequestCall(indexedDB, "deleteDatabase", [name]);
          }
        };

        if (typeof module !== "undefined") {
          module.exports = exp;
          module.exports.default = module.exports;
        } else {
          self.idb = exp;
        }
      })();
    </script>
    <script>
      const basicDatatypes = {
        something: [
          {
            isArray: true,
            isComplex: true,
            name: "markers",
            type: "visualization_msgs/Marker",
            arrayLength: undefined
          },
          {
            isArray: true,
            isComplex: true,
            name: "futureMarkers",
            type: "visualization_msgs/Marker",
            arrayLength: undefined
          }
        ],
        "visualization_msgs/MarkerArray": [
          {
            isArray: true,
            isComplex: true,
            arrayLength: undefined,
            name: "markers",
            type: "visualization_msgs/Marker"
          }
        ],
        "visualization_msgs/Marker": [
          { type: "uint8", name: "ARROW", isConstant: true, value: 0 },
          { type: "uint8", name: "CUBE", isConstant: true, value: 1 },
          { type: "uint8", name: "SPHERE", isConstant: true, value: 2 },
          { type: "uint8", name: "CYLINDER", isConstant: true, value: 3 },
          { type: "uint8", name: "LINE_STRIP", isConstant: true, value: 4 },
          { type: "uint8", name: "LINE_LIST", isConstant: true, value: 5 },
          { type: "uint8", name: "CUBE_LIST", isConstant: true, value: 6 },
          { type: "uint8", name: "SPHERE_LIST", isConstant: true, value: 7 },
          { type: "uint8", name: "POINTS", isConstant: true, value: 8 },
          {
            type: "uint8",
            name: "TEXT_VIEW_FACING",
            isConstant: true,
            value: 9
          },
          { type: "uint8", name: "MESH_RESOURCE", isConstant: true, value: 10 },
          { type: "uint8", name: "TRIANGLE_LIST", isConstant: true, value: 11 },
          { type: "uint8", name: "ADD", isConstant: true, value: 0 },
          { type: "uint8", name: "MODIFY", isConstant: true, value: 0 },
          { type: "uint8", name: "DELETE", isConstant: true, value: 2 },
          {
            type: "std_msgs/Header",
            name: "header",
            isArray: false,
            isComplex: true
          },
          { type: "string", name: "ns", isArray: false, isComplex: false },
          { type: "int32", name: "id", isArray: false, isComplex: false },
          { type: "int32", name: "type", isArray: false, isComplex: false },
          { type: "int32", name: "action", isArray: false, isComplex: false },
          {
            type: "geometry_msgs/Pose",
            name: "pose",
            isArray: false,
            isComplex: true
          },
          {
            type: "geometry_msgs/Vector3",
            name: "scale",
            isArray: false,
            isComplex: true
          },
          {
            type: "std_msgs/ColorRGBA",
            name: "color",
            isArray: false,
            isComplex: true
          },
          {
            type: "duration",
            name: "lifetime",
            isArray: false,
            isComplex: false
          },
          {
            type: "bool",
            name: "frame_locked",
            isArray: false,
            isComplex: false
          },
          {
            type: "geometry_msgs/Point",
            name: "points",
            isArray: true,
            arrayLength: undefined,
            isComplex: true
          },
          {
            type: "std_msgs/ColorRGBA",
            name: "colors",
            isArray: true,
            arrayLength: undefined,
            isComplex: true
          },
          { type: "string", name: "text", isArray: false, isComplex: false },
          {
            type: "string",
            name: "mesh_resource",
            isArray: false,
            isComplex: false
          },
          {
            type: "bool",
            name: "mesh_use_embedded_materials",
            isArray: false,
            isComplex: false
          }
        ],
        "std_msgs/ColorRGBA": [
          { type: "float32", name: "r", isArray: false, isComplex: false },
          { type: "float32", name: "g", isArray: false, isComplex: false },
          { type: "float32", name: "b", isArray: false, isComplex: false },
          { type: "float32", name: "a", isArray: false, isComplex: false }
        ],
        "std_msgs/Header": [
          { type: "uint32", name: "seq", isArray: false, isComplex: false },
          { type: "time", name: "stamp", isArray: false, isComplex: false },
          { type: "string", name: "frame_id", isArray: false, isComplex: false }
        ],
        "geometry_msgs/Pose": [
          {
            type: "geometry_msgs/Point",
            name: "position",
            isArray: false,
            isComplex: true
          },
          {
            type: "geometry_msgs/Quaternion",
            name: "orientation",
            isArray: false,
            isComplex: true
          }
        ],
        "geometry_msgs/Vector3": [
          { type: "float64", name: "x", isArray: false, isComplex: false },
          { type: "float64", name: "y", isArray: false, isComplex: false },
          { type: "float64", name: "z", isArray: false, isComplex: false }
        ],
        "geometry_msgs/Point": [
          { type: "float64", name: "x", isArray: false, isComplex: false },
          { type: "float64", name: "y", isArray: false, isComplex: false },
          { type: "float64", name: "z", isArray: false, isComplex: false }
        ],
        "geometry_msgs/Quaternion": [
          { type: "float64", name: "x", isArray: false, isComplex: false },
          { type: "float64", name: "y", isArray: false, isComplex: false },
          { type: "float64", name: "z", isArray: false, isComplex: false },
          { type: "float64", name: "w", isArray: false, isComplex: false }
        ]
      };

      class Database {
        // gets a database at the specified version and handles creating object stores
        // and indexes based on the supplied DatabaseDefinition object
        static async get(definition) {
          const { name, version, objectStores } = definition;
          console.log("getting", name);
          const db = await idb.open(name, version, change => {
            [...change.objectStoreNames].forEach(name =>
              change.deleteObjectStore(name)
            );
            console.log("creating object store...", objectStores);
            objectStores.forEach(storeDefinition => {
              const { indexes = [] } = storeDefinition;
              const store = change.createObjectStore(
                storeDefinition.name,
                storeDefinition.options
              );
              indexes.forEach(index => {
                store.createIndex(index.name, index.keyPath);
              });
            });
          });
          return new Database(db);
        }

        constructor(db) {
          this.db = db;
        }

        close() {
          return this.db.close();
        }

        // put a single value with an optional key - uses autoIncrement if no key provided - returns the key
        async put(objectStore, value, key) {
          const tx = this.transaction(objectStore, "readwrite");
          const result = await tx.objectStore(objectStore).put(value, key);
          await tx.complete;
          return result;
        }

        transaction(storeNames, transactionMode) {
          return this.db.transaction(storeNames, transactionMode);
        }
      }

      function signal() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        promise.resolve = resolve;
        promise.reject = reject;
        return promise;
      }

      const deleteIdb = async name =>
        new Promise((resolve, reject) => {
          console.log("deleting...");
          const request = indexedDB.deleteDatabase(name);
          request.onerror = reject;
          request.onsuccess = resolve;
          request.onblocked = reject;
        });

      const STORE_NAME = "store";
      // const open = async name =>
      // new Promise((resolve, reject) => {
      // const request = indexedDB.open(name, 1);
      // request.onerror = reject;
      // request.onsuccess = e => resolve(e.target.result);
      // request.onupgradeneeded = e => {
      // const db = e.target.result;
      // const store = db.createObjectStore(STORE_NAME, {
      // autoIncrement: true
      // });
      // store.transaction.oncomplete = () => {
      // resolve(db);
      // };
      // store.transaction.onerror = reject;
      // };
      // });

      const openIdb = async definition => {
        const { name, version, objectStores } = definition;
        const db = await idb.open(name, version, change => {
          [...change.objectStoreNames].forEach(name =>
            change.deleteObjectStore(name)
          );
          objectStores.forEach(storeDefinition => {
            const { indexes = [] } = storeDefinition;
            const store = change.createObjectStore(
              storeDefinition.name,
              storeDefinition.options
            );
            indexes.forEach(index => {
              store.createIndex(index.name, index.keyPath);
            });
          });
        });
      };

      const put = async (db, value, key) =>
        new Promise(async (resolve, reject) => {
          const tx = db.transaction(STORE_NAME, "readwrite");
          tx.oncomplete = resolve;
          tx.onerror = reject;
          const store = tx.objectStore(STORE_NAME);
          const request = store.put(value, key);
          request.onerror = reject;
        });

      const fill = async db =>
        new Promise(async (resolve, reject) => {
          const tx = db.transaction(STORE_NAME, "readwrite");
          tx.oncomplete = resolve;
          tx.onerror = reject;
          const store = tx.objectStore(STORE_NAME);
          for (let i = 0; i < 50; i++) {
            // 1Mb * 100 = 0.05Gb per database
            const request = store.put({
              data: new Uint8Array(1e6).map(_ => Math.random() * 1000) /* 1Mb */
            });
            request.onerror = reject;
          }
        });

      const read = async db =>
        new Promise(async (resolve, reject) => {
          const tx = db.transaction(STORE_NAME);
          tx.oncomplete = resolve;
          tx.onerror = reject;
          const store = tx.objectStore(STORE_NAME);
          store.openCursor.onsuccess = event => {
            const cursor = event.target.result;
            if (!cursor) {
              return;
            }
            cursor.continue();
          };
        });

      window.tableflowDone = signal();

      (async () => {
        await Promise.all([
          (async () => {
            const databases = await window.indexedDB.databases();
            for (const { name } of databases) {
              if (name.startsWith("a")) {
                await deleteIdb(name);
              }
            }
            const aDbName = `a-${Math.floor(
              Math.random() * 10000000
            )}-52f5fbee-4f7f-55bb-a953-6e4ddf244319`;
            const aDb = await Database.get({
              name: aDbName,
              version: 1,
              objectStores: [
                {
                  name: STORE_NAME,
                  options: {
                    autoIncrement: true
                  }
                }
              ]
            });
            for (const [key, value] of Object.entries(basicDatatypes)) {
              await aDb.put(STORE_NAME, value, key);
            }
            window.tableflowDone.resolve();
            const tx = aDb.transaction([STORE_NAME]);
            const store = tx.objectStore(STORE_NAME);
            store.iterateCursor(cursor => {
              if (!cursor) {
                return;
              }
              cursor.continue();
            });
            await tx.complete;
          })(),
          (async () => {
            await window.tableflowDone;
            const databases = await window.indexedDB.databases();
            for (const { name } of databases) {
              if (name.startsWith("b")) {
                await deleteIdb(name);
              }
            }
            const bDbName = `b-IdbCacheDataProviderDb-https://datablaster.robot.car/v2/query/sim?hydra-run-id=a5881847-3a35-5179-969b-f0765872eb71-${Math.floor(
              Math.random() * 10000000
            )}`;
            const bDb = await Database.get({
              name: bDbName,
              version: 1,
              objectStores: [
                {
                  name: STORE_NAME,
                  options: {
                    autoIncrement: true
                  }
                }
              ]
            });
            const tx = bDb.transaction([STORE_NAME], "readwrite");
            const messagesStore = tx.objectStore(STORE_NAME);
            for (const _ of new Array(50).fill(null)) {
              const message = new Uint8Array(1e6).map(
                _ => Math.random() * 1000
              ); /* 0.1Mb */
              messagesStore.put({
                message
              });
            }
            await tx.complete;
          })()
        ]);

        // (async () => {
        // await Promise.all([
        // (async () => {
        // const databases = await window.indexedDB.databases();
        // for (const { name } of databases) {
        // if (name.startsWith("a")) {
        // await deleteIdb(name);
        // }
        // }
        // const aDbName = `a-${Math.floor(
        // Math.random() * 10000000
        // )}-52f5fbee-4f7f-55bb-a953-6e4ddf244319`;
        // const aDb = await open(aDbName);
        // for (const [key, value] of Object.entries(basicDatatypes)) {
        // await put(aDb, value, key);
        // }
        // window.tableflowDone.resolve();
        // await read(aDb);
        // })(),
        // (async () => {
        // await window.tableflowDone;
        // const databases = await window.indexedDB.databases();
        // for (const { name } of databases) {
        // if (name.startsWith("b")) {
        // await deleteIdb(name);
        // }
        // }
        // const bDbName = `b-IdbCacheDataProviderDb-https://datablaster.robot.car/v2/query/sim?hydra-run-id=a5881847-3a35-5179-969b-f0765872eb71-${Math.floor(
        // Math.random() * 10000000
        // )}`;
        // const bDb = await open(bDbName);
        // await fill(bDb);
        // })()
        // ]);

        if (!navigator || !navigator.storage || !navigator.storage.estimate) {
          throw new Error(
            "navigator.storage.estimate not supported; this repro only supports the latest version of Google Chrome"
          );
        }
        const estimate = await navigator.storage.estimate();
        const indexedDB = estimate.usageDetails.indexedDB;

        console.log("Done");

        document.body.innerText = `Total db size: ${indexedDB / 1e6}Mb`;
      })();
    </script>
  </body>
</html>
